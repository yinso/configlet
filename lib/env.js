// Generated by CoffeeScript 1.10.0
(function() {
  var EnvVarPath, Schema, normalize, normalizeArray, normalizeObject, normalizeOneOf, normalizeScalar, parseArray, parseObject, rJson, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Schema = require('schemalet');

  util = require('./util');

  rJson = require('relaxed-json');

  EnvVarPath = (function(superClass) {
    extend(EnvVarPath, superClass);

    function EnvVarPath(path, prev) {
      if (!(this instanceof EnvVarPath)) {
        return new EnvVarPath(path, prev);
      }
      EnvVarPath.__super__.constructor.call(this, path, prev);
    }

    EnvVarPath.prototype.push = function(path) {
      return new EnvVarPath(path, this);
    };

    EnvVarPath.prototype.getValue = function(envVars) {
      var name;
      name = this.toString();
      if (envVars.hasOwnProperty(name)) {
        return envVars[name];
      }
      name = name.toUpperCase();
      if (envVars.hasOwnProperty(name)) {
        return envVars[name];
      }
      name = name.toLowerCase();
      if (envVars.hasOwnProperty(name)) {
        return envVars[name];
      }
      return void 0;
    };

    EnvVarPath.prototype.toString = function() {
      var current, res;
      res = [];
      current = this;
      while (current) {
        if (current.path !== '') {
          res.unshift(current.path);
        }
        current = current.prev;
      }
      return res.join('_');
    };

    return EnvVarPath;

  })(Schema.SchemaPath);

  normalize = function(schema, envVars, path, acc) {
    if (path == null) {
      path = EnvVarPath();
    }
    if (acc == null) {
      acc = void 0;
    }
    schema = schema instanceof Schema ? schema : Schema.makeSchema(schema);
    switch (schema.type) {
      case 'integer':
      case 'boolean':
      case 'string':
      case 'number':
        return normalizeScalar(schema, envVars, path, acc);
      case 'array':
        return normalizeArray(schema, envVars, path, acc);
      case 'object':
        return normalizeObject(schema, envVars, path, acc);
      case 'oneOf':
        return normalizeOneOf(schema, envVars, path, acc);
      default:
        throw new Error("Unknown schema type: " + schema.type);
    }
  };

  normalizeArray = function(schema, envVars, path, acc) {
    var envVarName, val;
    envVarName = path.toString();
    val = path.getValue(envVars);
    if (util.isValue(val)) {
      return schema.convert(parseArray(val));
    } else {
      return void 0;
    }
  };

  normalizeOneOf = function(schema, envVars, path, acc) {
    var e, error, i, inner, len, ref;
    ref = schema.items;
    for (i = 0, len = ref.length; i < len; i++) {
      inner = ref[i];
      try {
        return normalize(inner, envVars, path, acc);
      } catch (error) {
        e = error;
        continue;
      }
    }
    return void 0;
  };

  normalizeScalar = function(schema, envVars, path, acc) {
    var val;
    val = path.getValue(envVars);
    if (util.isValue(val)) {
      return schema.convert(val);
    } else {
      return void 0;
    }
  };

  parseArray = function(str) {
    var postfix, prefix;
    prefix = str.match(/^\s*\[/) ? '' : '[';
    postfix = str.match(/\]\s*$/) ? '' : ']';
    return rJson.parse(prefix + str + postfix);
  };

  parseObject = function(str) {
    var postfix, prefix;
    prefix = str.match(/^\s*\{/) ? '' : '{';
    postfix = str.match(/\}\s*$/) ? '' : '}';
    return rJson.parse(prefix + str + postfix);
  };

  normalizeObject = function(schema, envVars, path, acc) {
    var i, inner, key, len, prop, ref, ref1, val;
    val = path.getValue(envVars);
    if (util.isValue(val)) {
      if (typeof val === 'string') {
        acc = normalize(schema, parseObject(val), path);
      } else if (val instanceof Object) {
        acc = normalize(schema, val, path);
      }
    }
    ref = schema.properties;
    for (i = 0, len = ref.length; i < len; i++) {
      ref1 = ref[i], key = ref1[0], prop = ref1[1];
      inner = normalize(prop, envVars, path.push(key));
      if (util.isValue(inner)) {
        if (!(acc instanceof Object)) {
          acc = {};
        }
        acc[key] = inner;
      }
    }
    return acc;
  };

  module.exports = {
    normalize: normalize,
    EnvVarPath: EnvVarPath
  };

}).call(this);
