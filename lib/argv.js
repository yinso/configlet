// Generated by CoffeeScript 1.10.0
(function() {
  var AppError, ArgvVarPath, Schema, _array, _map, _normalize, _object, _oneOf, _scalar, _tuple, normalize, parseArgv, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  parseArgv = require('minimist');

  Schema = require('schemalet');

  AppError = require('errorlet');

  util = require('./util');

  ArgvVarPath = (function(superClass) {
    extend(ArgvVarPath, superClass);

    function ArgvVarPath(path, prev) {
      if (prev == null) {
        prev = null;
      }
      if (!(this instanceof ArgvVarPath)) {
        return new ArgvVarPath(path, prev);
      }
      ArgvVarPath.__super__.constructor.call(this, path, prev);
    }

    return ArgvVarPath;

  })(Schema.SchemaPath);

  normalize = function(schema, argv) {
    var normalized;
    if (argv == null) {
      argv = process.argv;
    }
    normalized = util.normalizeKeys(parseArgv(argv));
    console.log('Argv.normalize', normalized);
    return _normalize(schema, normalized, new ArgvVarPath());
  };

  _normalize = function(schema, obj, path) {
    console.log("<" + schema.type + ">", obj, path.toString());
    switch (schema.type) {
      case 'integer':
      case 'number':
      case 'boolean':
      case 'string':
      case 'null':
        return _scalar(schema, obj, path);
      case 'array':
        return _array(schema, obj, path);
      case 'object':
        return _object(schema, obj, path);
      case 'map':
        return _map(schema, obj, path);
      case 'oneOf':
        return _oneOf(schema, obj, path);
    }
  };

  _scalar = function(schema, x, path) {
    var e, error;
    if (util.isValue(x)) {
      try {
        return schema.convert(x, path);
      } catch (error) {
        e = error;
        return void 0;
      }
    }
  };

  _array = function(schema, ary, path) {
    var e, error, i, item, j, len, results;
    if (ary instanceof Array) {
      results = [];
      for (i = j = 0, len = ary.length; j < len; i = ++j) {
        item = ary[i];
        try {
          results.push(_normalize(schema.inner, item, path.push(i)));
        } catch (error) {
          e = error;
          results.push(void 0);
        }
      }
      return results;
    } else {
      return void 0;
    }
  };

  _tuple = function(schema, ary, path) {
    var e, error, i, inner, j, len, ref, results;
    if (ary instanceof Array) {
      ref = schema.items;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        inner = ref[i];
        try {
          results.push(_normalize(inner, ary[i], path.push(i)));
        } catch (error) {
          e = error;
          results.push(void 0);
        }
      }
      return results;
    } else {
      return void 0;
    }
  };

  _object = function(schema, obj, path) {
    var j, key, len, prop, ref, ref1, res, result;
    if (obj instanceof Object) {
      result = {};
      ref = schema.properties;
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], key = ref1[0], prop = ref1[1];
        if (obj.hasOwnProperty(key) && util.isValue(obj[key])) {
          res = _normalize(prop, obj[key], path.push(key));
          if (util.isValue(res)) {
            result[key] = res;
          }
        }
      }
      return result;
    } else {
      return void 0;
    }
  };

  _map = function(schema, obj, path) {
    var key, res, result, val;
    if (obj instanceof Object) {
      result = {};
      for (key in obj) {
        val = obj[key];
        if (obj.hasOwnproperty(key) && util.isValue(obj[key])) {
          res = _normalize(schema.inner, obj[key], path.push(key));
          if (util.isValue(res)) {
            result[key] = res;
          }
        }
      }
      return result;
    } else {
      return void 0;
    }
  };

  _oneOf = function(schema, obj, path) {
    var e, error, i, inner, j, len, ref;
    ref = schema.items;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      inner = ref[i];
      try {
        return _normalize(item, obj, path.push(i));
      } catch (error) {
        e = error;
        continue;
      }
    }
    return void 0;
  };

  module.exports = {
    normalize: normalize
  };

}).call(this);
