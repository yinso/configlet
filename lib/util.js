// Generated by CoffeeScript 1.10.0
(function() {
  var Schema, _array, _isArrayKeys, _object, intSchema, isFunction, isValue, merge, mergeArray, mergeObject, mergeScalar, normalizeKeys;

  isValue = function(x) {
    return x !== void 0 && x !== null;
  };

  isFunction = function(obj) {
    return (typeof obj === 'function') || (obj instanceof Function);
  };

  merge = function(target, source) {
    if ((target instanceof Array) && (source instanceof Array)) {
      return mergeArray(target, source);
    } else if ((target instanceof Array) || (source instanceof Array)) {
      return mergeScalar(target, source);
    } else if (isFunction(target) || isFunction(source)) {
      return mergeScalar(target, source);
    } else if ((target instanceof Object) && (source instanceof Object)) {
      return mergeObject(target, source);
    } else if ((target instanceof Object) && (source === void 0)) {
      return mergeObject(target, {});
    } else if ((target instanceof Object) || (source instanceof Object)) {
      throw new Error("both_must_be_object");
    } else {
      return mergeScalar(target, source);
    }
  };

  mergeScalar = function(target, source) {
    if (source === void 0 || source === null) {
      return target;
    } else {
      return source;
    }
  };

  mergeObject = function(target, source) {
    var key, res, val;
    res = {};
    for (key in target) {
      val = target[key];
      if (target.hasOwnProperty(key)) {
        res[key] = source.hasOwnProperty(key) ? merge(val, source[key]) : merge(val);
      }
    }
    for (key in source) {
      val = source[key];
      if (source.hasOwnProperty(key)) {
        if (!res.hasOwnProperty(key)) {
          res[key] = val;
        }
      }
    }
    return res;
  };

  mergeArray = function(target, source) {
    var i, item, j, k, len, len1, map, res;
    map = {};
    res = [];
    for (i = j = 0, len = target.length; j < len; i = ++j) {
      item = target[i];
      map[JSON.stringify(item)] = item;
      res.push(item);
    }
    for (i = k = 0, len1 = source.length; k < len1; i = ++k) {
      item = source[i];
      if (!map.hasOwnProperty(JSON.stringify(item))) {
        res.push(item);
      }
    }
    return res;
  };

  Schema = require('schemalet');

  normalizeKeys = function(obj) {
    if (obj instanceof Array) {
      return _array(obj);
    } else if (obj instanceof Object) {
      return _object(obj);
    } else {
      return obj;
    }
  };

  _array = function(obj) {
    var item, j, len, results;
    results = [];
    for (j = 0, len = obj.length; j < len; j++) {
      item = obj[j];
      results.push(normalizeKeys(item));
    }
    return results;
  };

  intSchema = Schema.makeSchema({
    type: 'integer'
  });

  _isArrayKeys = function(keys) {
    var e, error, j, key, len;
    for (j = 0, len = keys.length; j < len; j++) {
      key = keys[j];
      try {
        intSchema.convert(key);
      } catch (error) {
        e = error;
        return false;
      }
    }
    return true;
  };

  _object = function(obj) {
    var key, keys, res, results, val;
    keys = Object.keys(obj);
    if (_isArrayKeys(keys)) {
      res = [];
      results = [];
      for (key in obj) {
        val = obj[key];
        results.push(res[intSchema.convert(key)] = normalizeKeys(val));
      }
      return results;
    } else {
      res = {};
      for (key in obj) {
        val = obj[key];
        res[key] = normalizeKeys(val);
      }
      return res;
    }
  };

  module.exports = {
    merge: merge,
    isValue: isValue,
    isFunction: isFunction,
    normalizeKeys: normalizeKeys
  };


  /* park this here for now
  
  deepEqual = (a, b) ->
    typeA = typeof a
    typeB = typeof b
    if typeA == typeB
      switch typeA
        when 'number', 'string', 'boolean', 'undefined'
          return a == b
        else # object
          if (a instanceof Array) and (b instanceof Array)
            return deepEqualArray a, b
          else
            return deepEqualObject a, b
    else
      false
  
  deepEqualArray = (a, b) ->
    if a.length != b.length
      return false
    for item, i in a
      if not deepEqual item, b[i]
        return false
    true
  
  deepEqualObject = (a, b) ->
    if Object.keys(a).length != Object.keys(b).length
      return false
    for key, val of a
      if a.hasOwnProperty key
        if not b.hasOwnProperty key
          return false
        if not deepEqual val, b[key]
          return false
    true
   */


  /*
  class List
  
    class ListEnd extends List
  
    @End = new ListEnd()
  
    @fromArray: (ary) ->
      current = End
      for item in ary
        current = Cons item, current
      current.reverse()
  
    constructor: (head, tail = End) ->
      if not (@ instanceof List)
        return new List head, tail
      @head = head
      @tail = tail
  
    isEnd: () ->
      @tail == End
  
    toArray: () ->
      ary = []
      current = @
      while not current.isEnd()
        ary.push current.head
        current = current.tail
      ary
  
    reverse: () ->
      res = End
      current = @
      while not current.isEnd()
        res = List current.head, res
        current = current.tail
      res
   */

}).call(this);
